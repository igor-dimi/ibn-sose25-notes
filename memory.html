<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Memory Management – Operating Systems and Networks SoSe 25 Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./networks-intro.html" rel="next">
<link href="./process.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-d558773541b75318fdba2db46f940219.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./process.html">Operating Systems</a></li><li class="breadcrumb-item"><a href="./memory.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Memory Management</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Operating Systems and Networks SoSe 25 Notes</a> 
        <div class="sidebar-tools-main">
    <a href="./Operating-Systems-and-Networks-SoSe-25-Notes.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Operating Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./process.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Process Management</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./memory.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Memory Management</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Networks</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./networks-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Network Fundamentals - Summary of Slides 1 - 45</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./application-layer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Intro to the Application Layer, Web and HTTP</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#virtual-memory" id="toc-virtual-memory" class="nav-link active" data-scroll-target="#virtual-memory">Virtual Memory</a>
  <ul>
  <li><a href="#paging" id="toc-paging" class="nav-link" data-scroll-target="#paging">Paging</a>
  <ul>
  <li><a href="#translating-logical-to-physical-addresses" id="toc-translating-logical-to-physical-addresses" class="nav-link" data-scroll-target="#translating-logical-to-physical-addresses">Translating Logical to Physical Addresses</a>
  <ul class="collapse">
  <li><a href="#context" id="toc-context" class="nav-link" data-scroll-target="#context">Context</a></li>
  <li><a href="#example-setup" id="toc-example-setup" class="nav-link" data-scroll-target="#example-setup">Example Setup</a></li>
  <li><a href="#step-1-manual-arithmetic-calculation" id="toc-step-1-manual-arithmetic-calculation" class="nav-link" data-scroll-target="#step-1-manual-arithmetic-calculation">Step 1: Manual (Arithmetic) Calculation</a></li>
  <li><a href="#step-2-bitwise-calculation-optimized-for-hardware" id="toc-step-2-bitwise-calculation-optimized-for-hardware" class="nav-link" data-scroll-target="#step-2-bitwise-calculation-optimized-for-hardware">Step 2: Bitwise Calculation (Optimized for Hardware)</a></li>
  <li><a href="#bit-sequence-visualization" id="toc-bit-sequence-visualization" class="nav-link" data-scroll-target="#bit-sequence-visualization">Bit Sequence Visualization</a></li>
  <li><a href="#why-this-works-mathematically" id="toc-why-this-works-mathematically" class="nav-link" data-scroll-target="#why-this-works-mathematically">Why This Works Mathematically</a></li>
  <li><a href="#final-formula" id="toc-final-formula" class="nav-link" data-scroll-target="#final-formula">Final Formula</a></li>
  <li><a href="#additional-example-for-practice-and-clarity" id="toc-additional-example-for-practice-and-clarity" class="nav-link" data-scroll-target="#additional-example-for-practice-and-clarity">Additional Example for Practice and Clarity</a></li>
  <li><a href="#using-the-formula" id="toc-using-the-formula" class="nav-link" data-scroll-target="#using-the-formula">Using the Formula</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  <li><a href="#page-tables" id="toc-page-tables" class="nav-link" data-scroll-target="#page-tables">Page Tables</a>
  <ul class="collapse">
  <li><a href="#single-level-direct-page-tables" id="toc-single-level-direct-page-tables" class="nav-link" data-scroll-target="#single-level-direct-page-tables">Single-Level (Direct) Page Tables</a></li>
  <li><a href="#why-single-level-tables-are-impractical" id="toc-why-single-level-tables-are-impractical" class="nav-link" data-scroll-target="#why-single-level-tables-are-impractical">Why Single-Level Tables Are Impractical</a></li>
  <li><a href="#frame-table-global-physical-memory-tracking" id="toc-frame-table-global-physical-memory-tracking" class="nav-link" data-scroll-target="#frame-table-global-physical-memory-tracking">Frame Table (Global Physical Memory Tracking)</a></li>
  <li><a href="#inverted-page-tables" id="toc-inverted-page-tables" class="nav-link" data-scroll-target="#inverted-page-tables">Inverted Page Tables</a></li>
  <li><a href="#hierarchical-page-tables" id="toc-hierarchical-page-tables" class="nav-link" data-scroll-target="#hierarchical-page-tables">Hierarchical Page Tables</a></li>
  <li><a href="#when-and-how-page-tables-are-allocated" id="toc-when-and-how-page-tables-are-allocated" class="nav-link" data-scroll-target="#when-and-how-page-tables-are-allocated">When and How Page Tables Are Allocated</a></li>
  <li><a href="#physical-memory-frames-and-their-usage" id="toc-physical-memory-frames-and-their-usage" class="nav-link" data-scroll-target="#physical-memory-frames-and-their-usage">Physical Memory: Frames and Their Usage</a></li>
  <li><a href="#kernel-mapping-and-access" id="toc-kernel-mapping-and-access" class="nav-link" data-scroll-target="#kernel-mapping-and-access">Kernel Mapping and Access</a></li>
  <li><a href="#translation-lookaside-buffer" id="toc-translation-lookaside-buffer" class="nav-link" data-scroll-target="#translation-lookaside-buffer">Translation Lookaside Buffer</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./process.html">Operating Systems</a></li><li class="breadcrumb-item"><a href="./memory.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Memory Management</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Memory Management</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="virtual-memory" class="level2">
<h2 class="anchored" data-anchor-id="virtual-memory">Virtual Memory</h2>
<section id="paging" class="level3">
<h3 class="anchored" data-anchor-id="paging">Paging</h3>
<section id="translating-logical-to-physical-addresses" class="level4">
<h4 class="anchored" data-anchor-id="translating-logical-to-physical-addresses">Translating Logical to Physical Addresses</h4>
<section id="context" class="level5">
<h5 class="anchored" data-anchor-id="context">Context</h5>
<p>In paging, the operating system divides:</p>
<ul>
<li>Logical (virtual) memory into fixed-size pages</li>
<li>Physical memory (RAM) into same-size frames</li>
</ul>
<p>Each process has a page table that maps page numbers to frame numbers.</p>
<p>Our goal is:</p>
<blockquote class="blockquote">
<p>Given a virtual address, compute the corresponding physical address.</p>
</blockquote>
</section>
<section id="example-setup" class="level5">
<h5 class="anchored" data-anchor-id="example-setup">Example Setup</h5>
<ul>
<li>Virtual address <span class="math inline">\(V = 7000\)</span></li>
<li>Page size = 4096 bytes = <span class="math inline">\(2^{12}\)</span> ⇒ <span class="math inline">\(k = 12\)</span></li>
<li>Assume the page table maps page 1 to frame 9: <span class="math inline">\(F(1) = 9\)</span></li>
</ul>
</section>
<section id="step-1-manual-arithmetic-calculation" class="level5">
<h5 class="anchored" data-anchor-id="step-1-manual-arithmetic-calculation">Step 1: Manual (Arithmetic) Calculation</h5>
<p>To translate a virtual address manually, we need to answer two questions:</p>
<ol type="1">
<li><strong>Which page</strong> is the address in?</li>
<li><strong>Where within that page</strong> is the address?</li>
</ol>
<p>This is done by:</p>
<ul>
<li>Dividing the address by the page size to get the <strong>page number</strong></li>
<li>Taking the remainder (modulo) to get the <strong>offset</strong> within the page</li>
</ul>
<p>Apply this to <span class="math inline">\(V = 7000\)</span> with page size 4096:</p>
<ul>
<li>Page number <span class="math inline">\(p = \left\lfloor \frac{7000}{4096} \right\rfloor = 1\)</span></li>
<li>Offset <span class="math inline">\(d = 7000 \mod 4096 = 2904\)</span></li>
</ul>
<p>Now we look up page 1 in the page table:</p>
<ul>
<li>Frame number <span class="math inline">\(f = F(1) = 9\)</span></li>
</ul>
<p>To get the final physical address, we compute the base address of frame 9 and add the offset:</p>
<ul>
<li>Physical address = <span class="math inline">\(f \cdot 4096 + d = 9 \cdot 4096 + 2904 = 39768\)</span></li>
</ul>
<p>Result: 39768</p>
</section>
<section id="step-2-bitwise-calculation-optimized-for-hardware" class="level5">
<h5 class="anchored" data-anchor-id="step-2-bitwise-calculation-optimized-for-hardware">Step 2: Bitwise Calculation (Optimized for Hardware)</h5>
<p>For power-of-two page sizes, the address can be efficiently split using bitwise operations:</p>
<ul>
<li>Page number = <span class="math inline">\(V \gg 12\)</span> (right shift by 12 bits is equivalent to dividing by 4096)</li>
<li>Offset = <span class="math inline">\(V \&amp; (2^{12} - 1) = V \&amp; 0xFFF\)</span> (bit mask keeps the lower 12 bits)</li>
<li>Page number 1 maps to frame number <span class="math inline">\(f = F(1) = 9\)</span></li>
</ul>
<p>To compute the <strong>frame’s starting address</strong>, we use a left shift:</p>
<ul>
<li><span class="math inline">\(f \ll 12 = 9 \ll 12 = 36864\)</span>, which is equivalent to <span class="math inline">\(9 \cdot 4096\)</span></li>
</ul>
<p>Final physical address:</p>
<ul>
<li><span class="math inline">\(\text{Physical Address} = 36864 + 2904 = 39768\)</span></li>
</ul>
<p>Same result, now using fast bit operations.</p>
</section>
<section id="bit-sequence-visualization" class="level5">
<h5 class="anchored" data-anchor-id="bit-sequence-visualization">Bit Sequence Visualization</h5>
<p>Let’s visualize how the virtual address is split in binary:</p>
<ul>
<li>Virtual address <span class="math inline">\(V = 7000\)</span></li>
<li>Binary representation (14 bits): <code>0001 1011 0101 1000</code></li>
</ul>
<p>Split into:</p>
<ul>
<li>Page number (upper 2 bits): <code>00 01</code> → 1</li>
<li>Offset (lower 12 bits): <code>1011 0101 1000</code> → 2904</li>
</ul>
<p>This split works because:</p>
<ul>
<li>The lower 12 bits represent the offset for a 4 KB page</li>
<li>The upper bits index into the page table</li>
</ul>
</section>
<section id="why-this-works-mathematically" class="level5">
<h5 class="anchored" data-anchor-id="why-this-works-mathematically">Why This Works Mathematically</h5>
<p>The logic behind using bit shifts and masks instead of division and modulo is based on how numbers are represented in binary.</p>
<section id="decimal-analogy-base-10" class="level6">
<h6 class="anchored" data-anchor-id="decimal-analogy-base-10">Decimal Analogy (Base 10)</h6>
<p>Consider dividing <code>1375</code> by powers of 10:</p>
<ul>
<li>137<strong>5</strong> ÷ 10¹ = 137 (modulo: <strong>5</strong>)</li>
<li>13<strong>75</strong> ÷ 10² = 13 (modulo: <strong>75</strong>)</li>
<li>1<strong>375</strong> ÷ 10³ = 1 (modulo: <strong>375</strong>)</li>
</ul>
<p>The rightmost digits are the remainder (modulo); the left are the quotient (division).</p>
</section>
<section id="binary-example-base-2" class="level6">
<h6 class="anchored" data-anchor-id="binary-example-base-2">Binary Example (Base 2)</h6>
<p>Take the binary number <code>1011₂</code> (= 11₁₀):</p>
<ul>
<li>101<strong>1</strong> ÷ 2¹ = 101 = 5 (modulo: <strong>1</strong>)</li>
<li>10<strong>11</strong> ÷ 2² = 10 = 2 (modulo: <strong>11</strong> = 3)</li>
<li>1<strong>011</strong> ÷ 2³ = 1 = 1 (modulo: <strong>011</strong> = 3)</li>
</ul>
<p>In both systems, the rightmost digits/bits represent the <strong>offset</strong>, and the leftmost represent the <strong>page number</strong>.</p>
<p>This is why in binary:</p>
<ul>
<li><span class="math inline">\(V \gg k\)</span> is equivalent to <span class="math inline">\(\left\lfloor V / 2^k \right\rfloor\)</span></li>
<li><span class="math inline">\(V \&amp; (2^k - 1)\)</span> is equivalent to <span class="math inline">\(V \mod 2^k\)</span></li>
<li><span class="math inline">\(f \ll k\)</span> is equivalent to <span class="math inline">\(f \cdot 2^k\)</span>, which gives the frame base address</li>
</ul>
<p>These operations are both mathematically correct and hardware-efficient.</p>
</section>
</section>
<section id="final-formula" class="level5">
<h5 class="anchored" data-anchor-id="final-formula">Final Formula</h5>
<p><span class="math display">\[
\text{Physical Address} = \left( F(V \gg k) \ll k \right) + \left( V \&amp; (2^k - 1) \right)
\]</span></p>
<p>This computes:</p>
<ul>
<li>The page number via right shift</li>
<li>The frame number from the page table</li>
<li>The frame base via left shift (i.e., multiplying by page size)</li>
<li>The final physical address by adding the offset</li>
</ul>
</section>
<section id="additional-example-for-practice-and-clarity" class="level5">
<h5 class="anchored" data-anchor-id="additional-example-for-practice-and-clarity">Additional Example for Practice and Clarity</h5>
<p>Let’s now take another address and apply all three methods for reinforcement.</p>
<section id="setup" class="level6">
<h6 class="anchored" data-anchor-id="setup">Setup</h6>
<ul>
<li>Virtual address <span class="math inline">\(V = 13,\!452\)</span></li>
<li>Page size = 4096 = <span class="math inline">\(2^{12}\)</span></li>
<li>Page table:</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Page #</th>
<th>Frame #</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
</tr>
<tr class="even">
<td>1</td>
<td>7</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="manual-calculation" class="level6">
<h6 class="anchored" data-anchor-id="manual-calculation">Manual Calculation</h6>
<ul>
<li>Page number: <span class="math inline">\(13,\!452 \div 4096 = 3\)</span></li>
<li>Offset: <span class="math inline">\(13,\!452 \mod 4096 = 1164\)</span></li>
<li>Frame number: <span class="math inline">\(F(3) = 6\)</span></li>
<li>Physical address = <span class="math inline">\(6 \cdot 4096 + 1164 = 24,\!576 + 1164 = 25,\!740\)</span></li>
</ul>
</section>
<section id="bitwise-calculation" class="level6">
<h6 class="anchored" data-anchor-id="bitwise-calculation">Bitwise Calculation</h6>
<ul>
<li><span class="math inline">\(V = 13,\!452 = 0b0011\ 0100\ 1001\ 1100\)</span></li>
<li>Page number = <span class="math inline">\(V \gg 12 = 3\)</span></li>
<li>Offset = <span class="math inline">\(V \&amp; 0xFFF = 1164\)</span></li>
<li>Frame number = <span class="math inline">\(F(3) = 6\)</span></li>
<li>Frame base = <span class="math inline">\(6 \ll 12 = 24,\!576\)</span></li>
<li>Physical address = <span class="math inline">\(24,\!576 + 1164 = 25,\!740\)</span></li>
</ul>
</section>
</section>
<section id="using-the-formula" class="level5">
<h5 class="anchored" data-anchor-id="using-the-formula">Using the Formula</h5>
<p><span class="math display">\[
\text{Physical Address} = (F(V \gg 12) \ll 12) + (V \&amp; 0xFFF)
\]</span></p>
<p><span class="math display">\[
= (6 \ll 12) + 1164 = 24,\!576 + 1164 = 25,\!740
\]</span></p>
</section>
<section id="conclusion" class="level5">
<h5 class="anchored" data-anchor-id="conclusion">Conclusion</h5>
<p>When the page size is a power of two, address translation can be performed using fast bit operations instead of division and modulo. This is possible because of how binary numbers encode positional value. We saw that the lower bits give the offset and the upper bits the page number. Whether done manually, with bit operations, or using the translation formula, all approaches yield the same physical address — and this consistency is what makes paging both robust and efficient.</p>
<p>Absolutely — here is the <strong>complete regenerated summary</strong>, now incorporating:</p>
<ul>
<li><p>The <strong>updated “Inverted Page Tables”</strong> section with size explanation and example</p></li>
<li><p>The <strong>updated “Hierarchical Page Tables”</strong> section with both the 32-bit and 64-bit address resolution examples and definitions of each table level</p></li>
<li><p>Consistent formatting throughout:</p>
<ul>
<li><strong>No bold in headers</strong></li>
<li><strong>Minimal boldface emphasis</strong> in the text — used only where strictly useful for clarity</li>
</ul></li>
</ul>
<p>This version is fully ready for integration into your Quarto notes.</p>
<hr>
</section>
</section>
<section id="page-tables" class="level4">
<h4 class="anchored" data-anchor-id="page-tables">Page Tables</h4>
<section id="single-level-direct-page-tables" class="level5">
<h5 class="anchored" data-anchor-id="single-level-direct-page-tables">Single-Level (Direct) Page Tables</h5>
<p>In the simplest form of paging, each process has its own single-level page table, which directly maps virtual page numbers to physical frame numbers.</p>
<p>For example, in a system with:</p>
<ul>
<li>A 32-bit virtual address space (4 GB total)</li>
<li>A page size of 4 KB = <span class="math inline">\(2^{12}\)</span> bytes</li>
</ul>
<p>The number of virtual pages is:</p>
<p><span class="math display">\[
2^{32} / 2^{12} = 2^{20} = 1,\!048,\!576 \text{ entries}
\]</span></p>
<p>If each page table entry (PTE) is 4 bytes, the total size of the page table is:</p>
<p><span class="math display">\[
2^{20} \times 4 = 4 \text{ MB per process}
\]</span></p>
<p>In a 64-bit system, even with larger pages (e.g.&nbsp;4 MB), the number of virtual pages is so large (e.g., <span class="math inline">\(2^{52}\)</span>) that flat page tables become completely impractical.</p>
<hr>
</section>
<section id="why-single-level-tables-are-impractical" class="level5">
<h5 class="anchored" data-anchor-id="why-single-level-tables-are-impractical">Why Single-Level Tables Are Impractical</h5>
<p>Main issues:</p>
<ul>
<li>Memory usage per process becomes excessive (e.g., 4 MB/page table × hundreds of processes)</li>
<li>Scaling issues as address spaces grow</li>
<li>Most processes use only a small part of their virtual address space, so allocating full page tables is wasteful</li>
</ul>
<p>Thus, alternative paging strategies are needed.</p>
<hr>
</section>
<section id="frame-table-global-physical-memory-tracking" class="level5">
<h5 class="anchored" data-anchor-id="frame-table-global-physical-memory-tracking">Frame Table (Global Physical Memory Tracking)</h5>
<p>The OS maintains a global frame table, which tracks:</p>
<ul>
<li>Which physical frames are in use</li>
<li>What each frame is used for (user page, kernel structure, page table, etc.)</li>
<li>Associated metadata: dirty bit, reference count, owner process</li>
</ul>
<p>This allows the OS to allocate and deallocate physical memory intelligently and safely. It is also crucial for page replacement algorithms, memory protection, and managing shared pages or I/O buffers.</p>
<hr>
</section>
<section id="inverted-page-tables" class="level5">
<h5 class="anchored" data-anchor-id="inverted-page-tables">Inverted Page Tables</h5>
<p>In a traditional page table system, each process maintains its own page table, which maps virtual pages to physical frames. In contrast, an inverted page table uses a fundamentally different approach:</p>
<ul>
<li><p>There is a single global page table for the entire system</p></li>
<li><p>It contains one entry for each physical frame, not for each virtual page</p></li>
<li><p>Each entry records:</p>
<ul>
<li>The process ID that owns the frame</li>
<li>The virtual page number that maps to it</li>
<li>Any additional metadata (e.g., access flags, validity)</li>
</ul></li>
</ul>
<p>This approach dramatically reduces memory overhead, especially in systems with large virtual address spaces.</p>
<section id="size-of-the-inverted-page-table" class="level6">
<h6 class="anchored" data-anchor-id="size-of-the-inverted-page-table">Size of the inverted page table</h6>
<p>The size of an inverted page table depends only on the number of physical frames, which is determined by:</p>
<p><span class="math display">\[
\text{Number of entries} = \frac{\text{RAM size}}{\text{frame size}}
\]</span></p>
<p>Each entry stores fixed-size metadata (such as PID and VPN), so the total size is:</p>
<p><span class="math display">\[
\text{Table size} = \frac{\text{RAM size}}{\text{frame size}} \times \text{entry size}
\]</span></p>
<p>The ratio of the table size to RAM size simplifies to:</p>
<p><span class="math display">\[
\frac{\text{Table size}}{\text{RAM size}} = \frac{\text{entry size}}{\text{frame size}}
\]</span></p>
<p>This ratio is independent of total RAM size. In other words, the memory overhead of the page table scales proportionally with RAM but is bounded by the frame size and the entry size.</p>
</section>
<section id="concrete-example" class="level6">
<h6 class="anchored" data-anchor-id="concrete-example">Concrete example</h6>
<p>Consider a 32-bit system with the following properties:</p>
<ul>
<li>Physical RAM: 4 GB = <span class="math inline">\(2^{32}\)</span> bytes</li>
<li>Page/frame size: 4 KB = <span class="math inline">\(2^{12}\)</span> bytes</li>
<li>Page table entry size: 8 bytes (to store PID, VPN, flags, etc.)</li>
</ul>
<p>Step-by-step:</p>
<ol type="1">
<li>Number of physical frames:</li>
</ol>
<p><span class="math display">\[
\frac{2^{32}}{2^{12}} = 2^{20} = 1,\!048,\!576 \text{ frames}
\]</span></p>
<ol start="2" type="1">
<li>Total inverted page table size:</li>
</ol>
<p><span class="math display">\[
2^{20} \times 8 = 8 \text{ MB}
\]</span></p>
<ol start="3" type="1">
<li>Relative overhead:</li>
</ol>
<p><span class="math display">\[
\frac{8 \text{ MB}}{4 \text{ GB}} = \frac{1}{512}
\]</span></p>
<p>This means the page table occupies only about 0.2% of RAM.</p>
</section>
<section id="summary-of-trade-offs" class="level6">
<h6 class="anchored" data-anchor-id="summary-of-trade-offs">Summary of trade-offs</h6>
<p>Inverted page tables offer substantial memory savings, especially on systems with large or sparsely used virtual address spaces. However, the downside is that address translation becomes more complex:</p>
<ul>
<li>The system must search (or hash) the page table to find the matching (process ID, virtual page) pair</li>
<li>This lookup is slower than direct indexing</li>
<li>TLB caching becomes less straightforward</li>
</ul>
<p>For this reason, inverted page tables are rarely used in modern general-purpose OSes, though they are still valuable in embedded or resource-constrained systems.</p>
<hr>
</section>
</section>
<section id="hierarchical-page-tables" class="level5">
<h5 class="anchored" data-anchor-id="hierarchical-page-tables">Hierarchical Page Tables</h5>
<p>Modern systems (e.g., x86, Linux, Windows) use multi-level page tables to avoid allocating massive single-level tables for sparse address spaces. The key idea is to divide the virtual address into multiple segments, each of which indexes a level in the page table hierarchy. This allows the OS to only allocate memory for regions that are actually used.</p>
<p>Each level of the hierarchy resolves part of the virtual address and points to the next level down. The final level contains the physical frame number. The remaining bits (the offset) are added to form the final physical address.</p>
<p>This approach reduces memory overhead and supports sparse, large virtual address spaces.</p>
<section id="bit-two-level-paging-example" class="level6">
<h6 class="anchored" data-anchor-id="bit-two-level-paging-example">32-bit Two-Level Paging Example</h6>
<p>Assume a 32-bit virtual address space with:</p>
<ul>
<li>Page size = 4 KB = <span class="math inline">\(2^{12}\)</span></li>
<li>10 bits for the page directory index</li>
<li>10 bits for the page table index</li>
<li>12 bits for the offset</li>
</ul>
<p>The virtual address layout is:</p>
<pre><code>[ 10 bits | 10 bits | 12 bits ]
   PD index  PT index   Offset</code></pre>
<p>Suppose the virtual address is:</p>
<pre><code>VA = 0x1234ABCD</code></pre>
<p>Convert to binary:</p>
<pre><code>0001 0010 0011 0100 1010 1011 1100 1101</code></pre>
<p>Split:</p>
<ul>
<li>Page Directory index = <code>0001001000</code> = 0x048 = 72</li>
<li>Page Table index = <code>1101001010</code> = 0x34A = 842</li>
<li>Offset = <code>101111001101</code> = 0xBCD = 3021</li>
</ul>
<p>Assume:</p>
<ul>
<li>The page directory is located at physical address <code>0x00100000</code></li>
<li>Entry 72 in the page directory points to a page table at <code>0x00200000</code></li>
<li>Entry 842 in that page table points to a physical frame at <code>0x00ABC000</code></li>
</ul>
<p>Final physical address:</p>
<p><span class="math display">\[
0x00ABC000 + 0xBCD = 0x00ABCBCD
\]</span></p>
<p>This example illustrates how a 2-level table hierarchy resolves the virtual address to a physical address through two indirections and an offset.</p>
</section>
<section id="bit-four-level-paging-example" class="level6">
<h6 class="anchored" data-anchor-id="bit-four-level-paging-example">64-bit Four-Level Paging Example</h6>
<p>Modern x86-64 systems typically support a 48-bit virtual address space, split across four paging levels. The page size remains 4 KB = <span class="math inline">\(2^{12}\)</span>.</p>
<p>Each level of the hierarchy resolves 9 bits (since <span class="math inline">\(2^9 = 512\)</span> entries per table), so the full 48-bit address is broken into:</p>
<pre><code>[ 9 bits | 9 bits | 9 bits | 9 bits | 12 bits ]
  PML4     PDPT     PD       PT       Offset</code></pre>
<p>The levels are defined as follows:</p>
<ul>
<li>PML4 (Page Map Level 4): The root of the page table hierarchy; indexed by the top 9 bits of the virtual address. Each entry points to a PDPT.</li>
<li>PDPT (Page Directory Pointer Table): Intermediate level; each entry points to a Page Directory.</li>
<li>PD (Page Directory): Each entry points to a Page Table.</li>
<li>PT (Page Table): Final level; each entry contains a physical frame number.</li>
<li>Offset: Specifies the exact byte within the 4 KB page.</li>
</ul>
<p>Suppose the virtual address is:</p>
<pre><code>VA = 0x00007F34_1234ABCD</code></pre>
<p>Breaking down the lower 48 bits:</p>
<ul>
<li>PML4 index = bits 47–39 = 0</li>
<li>PDPT index = bits 38–30 = 505</li>
<li>PD index = bits 29–21 = 322</li>
<li>PT index = bits 20–12 = 210</li>
<li>Offset = bits 11–0 = 0xAF3D = 44861</li>
</ul>
<p>Assume the following physical mappings:</p>
<ul>
<li>CR3 register points to PML4 at <code>0x00100000</code></li>
<li>PML4 entry 0 → PDPT at <code>0x00200000</code></li>
<li>PDPT entry 505 → PD at <code>0x00300000</code></li>
<li>PD entry 322 → PT at <code>0x00400000</code></li>
<li>PT entry 210 → frame at <code>0x00ABC000</code></li>
</ul>
<p>Final physical address:</p>
<p><span class="math display">\[
0x00ABC000 + 0xAF3D = 0x00B06F3D
\]</span></p>
<p>This example demonstrates how a virtual address is translated step-by-step through four levels of indirection. The layered structure supports extremely large address spaces (up to 256 TB) without requiring full allocation of all intermediate tables.</p>
</section>
<section id="summary" class="level6">
<h6 class="anchored" data-anchor-id="summary">Summary</h6>
<p>Hierarchical page tables solve the scalability problem of flat page tables by breaking the virtual address into multiple segments. Each level of the hierarchy is a smaller table, and lower levels are allocated only when needed. This provides a sparse, memory-efficient structure for address translation.</p>
<p>The cost of additional indirection is mitigated by the use of TLBs, which cache recent address translations to avoid repeated page walks.</p>
<hr>
</section>
</section>
<section id="when-and-how-page-tables-are-allocated" class="level5">
<h5 class="anchored" data-anchor-id="when-and-how-page-tables-are-allocated">When and How Page Tables Are Allocated</h5>
<p>Page tables are allocated in two situations:</p>
<ol type="1">
<li><p>At program load time The OS allocates top-level tables and reserves virtual address regions for code, data, stack, etc., but not necessarily all intermediate tables.</p></li>
<li><p>On demand via page faults When a process accesses a virtual address with no current mapping, the CPU triggers a page fault. If the access is valid, the OS allocates missing intermediate page tables and a physical frame, updates the page table entries, and resumes execution.</p></li>
</ol>
<p>This approach enables sparse memory allocation and efficient use of physical memory.</p>
<hr>
</section>
<section id="physical-memory-frames-and-their-usage" class="level5">
<h5 class="anchored" data-anchor-id="physical-memory-frames-and-their-usage">Physical Memory: Frames and Their Usage</h5>
<p>RAM is divided into fixed-size frames (e.g., 4 KB). Each frame can hold:</p>
<ul>
<li>A user page (code, stack, heap)</li>
<li>A page table (of any level)</li>
<li>A kernel structure</li>
<li>Other memory-resident objects</li>
</ul>
<p>Contiguous physical frames may contain completely unrelated contents, as physical memory management is modular and page-based. The OS tracks frame usage via the global frame table.</p>
<hr>
</section>
<section id="kernel-mapping-and-access" class="level5">
<h5 class="anchored" data-anchor-id="kernel-mapping-and-access">Kernel Mapping and Access</h5>
<p>The kernel is mapped into the upper region of each process’s virtual address space (e.g., from <code>0xC0000000</code> upward in 32-bit systems). This allows:</p>
<ul>
<li>Fast system calls and interrupt handling</li>
<li>Avoiding page table switches on mode transitions</li>
</ul>
<p>This region is protected by page table flags, preventing access in user mode. The kernel itself runs entirely in kernel mode. Its physical location is determined at boot and may vary across systems. Techniques like KASLR (Kernel Address Space Layout Randomization) add further protection.</p>
<hr>
</section>
<section id="translation-lookaside-buffer" class="level5">
<h5 class="anchored" data-anchor-id="translation-lookaside-buffer">Translation Lookaside Buffer</h5>
<p>The TLB is a hardware-managed cache used by the MMU to store recently used virtual-to-physical page translations.</p>
<p>Why it’s important:</p>
<ul>
<li>Page walks involve multiple memory accesses</li>
<li>The TLB allows near-instant translation on a hit</li>
<li>Reduces the average cost of memory access in the presence of multi-level page tables</li>
</ul>
<p>TLBs are small (typically 16–512 entries) but highly effective due to temporal and spatial locality in most program behavior.</p>


</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./process.html" class="pagination-link" aria-label="Process Management">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Process Management</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./networks-intro.html" class="pagination-link" aria-label="Network Fundamentals - Summary of Slides 1 - 45">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Network Fundamentals - Summary of Slides 1 - 45</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>