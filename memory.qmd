---
title: Memory Management
---


## Virtual Memory

### Paging: Translating Logical to Physical Addresses

#### Context

In paging, the operating system divides:

* Logical (virtual) memory into fixed-size pages
* Physical memory (RAM) into same-size frames

Each process has a page table that maps page numbers to frame numbers.

Our goal is:

> Given a virtual address, compute the corresponding physical address.


#### Example Setup

* Virtual address $V = 7000$
* Page size = 4096 bytes = $2^{12}$ ⇒ $k = 12$
* Assume the page table maps page 1 to frame 9:
  $F(1) = 9$


#### Step 1: Manual (Arithmetic) Calculation

To translate a virtual address manually, we need to answer two questions:

1. **Which page** is the address in?
2. **Where within that page** is the address?

This is done by:

* Dividing the address by the page size to get the **page number**
* Taking the remainder (modulo) to get the **offset** within the page

Apply this to $V = 7000$ with page size 4096:

* Page number $p = \left\lfloor \frac{7000}{4096} \right\rfloor = 1$
* Offset $d = 7000 \mod 4096 = 2904$

Now we look up page 1 in the page table:

* Frame number $f = F(1) = 9$

To get the final physical address, we compute the base address of frame 9 and add the offset:

* Physical address = $f \cdot 4096 + d = 9 \cdot 4096 + 2904 = 39768$

Result: 39768

#### Step 2: Bitwise Calculation (Optimized for Hardware)

For power-of-two page sizes, the address can be efficiently split using bitwise operations:

* Page number = $V \gg 12$ (right shift by 12 bits is equivalent to dividing by 4096)
* Offset = $V \& (2^{12} - 1) = V \& 0xFFF$ (bit mask keeps the lower 12 bits)
* Page number 1 maps to frame number $f = F(1) = 9$

To compute the **frame’s starting address**, we use a left shift:

* $f \ll 12 = 9 \ll 12 = 36864$, which is equivalent to $9 \cdot 4096$

Final physical address:

* $\text{Physical Address} = 36864 + 2904 = 39768$

Same result, now using fast bit operations.


#### Bit Sequence Visualization

Let’s visualize how the virtual address is split in binary:

* Virtual address $V = 7000$
* Binary representation (14 bits):
  `0001 1011 0101 1000`

Split into:

* Page number (upper 2 bits): `00 01` → 1
* Offset (lower 12 bits): `1011 0101 1000` → 2904

This split works because:

* The lower 12 bits represent the offset for a 4 KB page
* The upper bits index into the page table

#### Why This Works Mathematically

The logic behind using bit shifts and masks instead of division and modulo is based on how numbers are represented in binary.

##### Decimal Analogy (Base 10)

Consider dividing `1375` by powers of 10:

* 137**5** ÷ 10¹ = 137 (modulo: **5**)
* 13**75** ÷ 10² = 13 (modulo: **75**)
* 1**375** ÷ 10³ = 1 (modulo: **375**)

The rightmost digits are the remainder (modulo); the left are the quotient (division).

##### Binary Example (Base 2)

Take the binary number `1011₂` (= 11₁₀):

* 101**1** ÷ 2¹ = 101 = 5 (modulo: **1**)
* 10**11** ÷ 2² = 10 = 2 (modulo: **11** = 3)
* 1**011** ÷ 2³ = 1 = 1 (modulo: **011** = 3)

In both systems, the rightmost digits/bits represent the **offset**, and the leftmost represent the **page number**.

This is why in binary:

* $V \gg k$ is equivalent to $\left\lfloor V / 2^k \right\rfloor$
* $V \& (2^k - 1)$ is equivalent to $V \mod 2^k$
* $f \ll k$ is equivalent to $f \cdot 2^k$, which gives the frame base address

These operations are both mathematically correct and hardware-efficient.


#### Final Formula

$$
\text{Physical Address} = \left( F(V \gg k) \ll k \right) + \left( V \& (2^k - 1) \right)
$$

This computes:

* The page number via right shift
* The frame number from the page table
* The frame base via left shift (i.e., multiplying by page size)
* The final physical address by adding the offset


#### Additional Example for Practice and Clarity

Let’s now take another address and apply all three methods for reinforcement.

##### Setup

* Virtual address $V = 13,\!452$
* Page size = 4096 = $2^{12}$
* Page table:

| Page # | Frame # |
| ------ | ------- |
| 0      | 3       |
| 1      | 7       |
| 2      | 1       |
| 3      | 6       |

##### Manual Calculation

* Page number: $13,\!452 \div 4096 = 3$
* Offset: $13,\!452 \mod 4096 = 1164$
* Frame number: $F(3) = 6$
* Physical address = $6 \cdot 4096 + 1164 = 24,\!576 + 1164 = 25,\!740$

##### Bitwise Calculation

* $V = 13,\!452 = 0b0011\ 0100\ 1001\ 1100$
* Page number = $V \gg 12 = 3$
* Offset = $V \& 0xFFF = 1164$
* Frame number = $F(3) = 6$
* Frame base = $6 \ll 12 = 24,\!576$
* Physical address = $24,\!576 + 1164 = 25,\!740$

#### Using the Formula

$$
\text{Physical Address} = (F(V \gg 12) \ll 12) + (V \& 0xFFF)
$$

$$
= (6 \ll 12) + 1164 = 24,\!576 + 1164 = 25,\!740
$$


#### Conclusion

When the page size is a power of two, address translation can be performed using fast bit operations instead of division and modulo. This is possible because of how binary numbers encode positional value. We saw that the lower bits give the offset and the upper bits the page number. Whether done manually, with bit operations, or using the translation formula, all approaches yield the same physical address — and this consistency is what makes paging both robust and efficient.


### Single-Level (Direct) Page Tables

In the simplest form of paging, each process has its own **single-level page table**, which directly maps **virtual page numbers** to **physical frame numbers**.

For example, in a system with:

* A **32-bit virtual address space** (4 GB total)
* A **page size of 4 KB = 2¹² bytes**

The number of virtual pages is:

$$
2^{32} / 2^{12} = 2^{20} = 1,\!048,\!576 \text{ entries}
$$

If each page table entry (PTE) is 4 bytes, the total size of the page table is:

$$
2^{20} \times 4 = 4 \text{ MB} \text{ per process}
$$

In a **64-bit system**, even with larger pages (e.g. 4 MB), the number of virtual pages is so large (e.g., $2^{52}$) that flat page tables become **completely impractical**.

---

### Why Single-Level Tables Are Impractical

Main issues:

* **Memory usage per process** becomes excessive (e.g., 4 MB/page table × hundreds of processes)
* **Scaling issues** as address spaces grow
* Most processes **use only a small part** of their virtual address space, so allocating full page tables is wasteful

Thus, alternative paging strategies are needed.

---

### Frame Table (Global Physical Memory Tracking)

The OS maintains a **frame table**, which tracks:

* Which physical frames are in use
* What each frame is used for (user page, kernel structure, page table, etc.)
* Associated metadata: dirty bit, reference count, owner process

This allows the OS to **allocate and deallocate physical memory** intelligently and safely, and is crucial for page replacement, memory protection, and I/O operations.

---

### Inverted Page Tables

Instead of one page table per process, an **inverted page table** contains **one entry per physical frame**. Each entry stores:

* **Process ID**
* **Virtual page number** mapped to this frame

The index in the table corresponds to the **physical frame number**.

Benefits:

* Memory usage depends only on **RAM size**, not virtual address space

Drawbacks:

* To resolve a virtual address, the system must **search (or hash)** the inverted table to find the matching (PID, VPN) pair
* More complex lookup; slower than indexed access
* Difficult to implement efficient TLB caching

Used in some older or memory-constrained systems, but rare in modern general-purpose OSes.

---

### Hierarchical Page Tables

Modern systems (e.g., x86, Linux, Windows) use **multi-level page tables** to address sparsity in virtual memory usage.

The virtual address is divided into parts:

* Each part indexes a **level in the page table hierarchy**
* Only needed page table levels are **allocated on demand**

---

#### 32-bit Two-Level Paging Example

For a 32-bit address space with 4 KB pages:

$$
\text{Virtual address} = [10-bit Page Dir] | [10-bit Page Table] | [12-bit Offset]
$$

* 1024 entries in the **Page Directory (PD)**
* Each PD entry points to a **Page Table (PT)** with 1024 entries
* Final PT entry points to the **physical frame**

Only PD is allocated initially. PTs are created **only when needed**, saving memory.

---

#### 64-bit Four-Level Paging Example (x86-64)

Typically uses **48-bit virtual addresses**, split into:

$$
[9-bit PML4] | [9-bit PDPT] | [9-bit PD] | [9-bit PT] | [12-bit offset]
$$

Each level (PML4, PDPT, PD, PT) is 512 entries (9 bits).

This allows mapping of:

$$
512^4 \times 4\text{ KB} = 256 \text{ TB of virtual address space}
$$

Page tables are allocated **only as needed** — i.e., when a virtual page is first accessed.

---

### When and How Page Tables Are Allocated

Page tables are allocated in two situations:

1. **At program load time**

   * When the OS loads a process, it allocates top-level tables and reserves virtual regions for code, data, stack, etc.
   * Not all intermediate tables are allocated yet.

2. **On demand via page faults**

   * When a process accesses a virtual address with no current mapping, the CPU triggers a **page fault**
   * The OS checks if the access is valid (e.g., within heap or stack)
   * If valid:

     * Missing intermediate page tables are allocated
     * A physical frame is allocated
     * Page tables are updated
     * Execution resumes

---

### Physical Memory: Frames and Their Usage

RAM is divided into fixed-size **frames** (e.g., 4 KB). Each frame can hold:

* A user page (code, stack, heap)
* A page table (of any level)
* A kernel structure
* Anything the OS needs

Important: **contiguous physical frames may contain totally unrelated contents**, from different processes or different kinds of structures. The OS manages this via the frame table.

---

### Kernel Mapping and Access

* Kernel code and data are mapped into the **upper portion of each process’s virtual address space**

  * E.g., in 32-bit Linux: `0xC0000000 – 0xFFFFFFFF`
* This region is **not accessible in user mode** (protected by page table flags)

Benefits:

* Enables **fast system calls and interrupt handling** without switching page tables
* Avoids need to reload CR3 (page table base register) on each syscall

Kernel runs entirely in **kernel mode**, and its physical location is:

* Not fixed
* Determined at boot (by the bootloader)
* Mapped into kernel virtual memory

Modern systems may use **KASLR (Kernel Address Space Layout Randomization)** to randomize the kernel's location for security.

---

### Translation Lookaside Buffer

The TLB is a small, fast cache used by the CPU's MMU to store **recent virtual-to-physical translations**.

Why it's needed:

* Page table lookups involve multiple memory accesses (especially in multi-level schemes)
* TLB provides **near-instant translation** for repeated accesses

Effectiveness:

* Very high hit rate due to **spatial and temporal locality**
* TLBs are usually 16–512 entries
* Managed by the hardware; updated on TLB misses

---

### Final Thoughts

Modern virtual memory management systems are built around the idea of:

* **Sparse usage** of large address spaces
* **On-demand, hierarchical translation structures**
* **Fast caching and protection** mechanisms

Direct page tables are conceptually simple but infeasible for large systems. Hierarchical page tables, supported by frame tables and TLBs, provide the scalability, flexibility, and efficiency required in today’s general-purpose operating systems.

---
